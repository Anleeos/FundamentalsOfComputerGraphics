# 1 导论
计算机图形学一词指利用计算机来创建和操纵图像的任何方法。本书介绍了可以用来创建各种图像的算法和数学工具——包括逼真的视觉效果、信息丰富的技术插图或漂亮的计算机动画。图形可以是二维或三维的；图像可以是完全合成的，也是编辑图片产生的。本书关注基本的算法和数学，特别是用于生成三维对象和场景的合成图像的算法和数学。

实际学习计算机图形学时，不可避免地需要了解特定的硬件、文件格式，通常还需要掌握一个或两个图形 API（参见[第1.3节](#13-图形学-api)）。计算机图形学是一个迅速发展的领域，因此相关知识的具体内容不断变化。因此，在本书中，我们尽力避免依赖任何特定的硬件或 API ，鼓励读者通过相关文档来补充他们的软件和硬件环境的信息。计算机图形学领域有着足够标准的术语和概念，本书中的内容可以很好地应用于大多数环境。

本章定义了一些基本术语，并提供了一些与计算机图形学相关的历史背景和信息来源。

# 1.1 图形学领域
在任何领域中强加分类都是危险的，但大多数图形学从业者可能会就计算机图形学的以下主要领域达成一致：

- **建模（Modeling）** 在计算机上储存和处理形状和外观属性的数学方法。例如，一个咖啡杯可以被描述为一组有序的3D点，以及连接这些点的插值规则与光与杯子相互作用的反射模型。

- **渲染（Rendering）** 是从艺术中继承而来的术语，它涉及从 3D 计算机模型创建阴影图像的过程。

- **动画（Animation）** 是通过图像序列创建运动错觉的技术。动画在建模和渲染的基础上还涉及一个关键问题，即随时间变化的运动，而在在通常的建模和渲染中不会涉及。

还有许多涉及计算机图形学的其他领域，它们是否属于核心图形领域完全依据主观判断。这些领域在本文中也会被提及。一些相关的领域包括以下内容：

* 用户交互（User interaction）（如鼠标和平板电脑）、应用程序、以图像形式向用户提供的反馈以及其他感觉反馈之间的接口。从历史上看，这个领域之所以与图形学相关，是因为图形学研究人员是最早接触到如今无处不在的输入/输出设备的一批人。
* 虚拟现实（Virtual reality）试图使用户沉浸到一个 3D 虚拟世界中。该技术通常需要立体图形以及对头部运动有所响应。真正的虚拟现实还应该有声音和力量反馈。因为这个领域需要先进的 3D 图形和高级的显示技术，所以它经常与图形学密切相关。
* 可视化（Visualization）试图通过视觉显示向用户提供对复杂信息的视野。通常在可视化问题中需要解决一些图形问题。
* 图像处理（Image processing）涉及对 2D 图像的处理，在图形学和计算机视觉领域都有所应用。
* 3D扫描（3D scanning）使用测距技术创建测得的 3D 模型。这样的模型对于创建丰富的视觉图像很有用，处理这些模型通常需要图形学算法。
* 计算摄影（Computational photography）是利用计算机图形学、计算机视觉和图像处理方法，以实现在摄影上捕捉物体、场景和环境的新方法。

# 1.2 主要应用
虽然几乎任何领域都可以利用计算机图形学，但计算机图形技术的使用者主要在以下行业：

* **视频游戏** 日益使用复杂的3D模型和渲染算法。

* **卡通** 通常直接从3D模型渲染。许多传统的 2D 卡通使用从 3D 模型渲染的背景，这样可以在节省大量绘制时间的情况下实现连续移动的图像。

* **视觉效果** 几乎使用了所有类型的计算机图形技术。差不多每一部现代电影都使用数字合成将背景与分开拍摄的前景叠加。许多电影还使用 3D 建模和动画来创建合成环境、物体，甚至是大多数观众永远都不会感到怀疑的逼真角色。

* **动画电影** 使用许多与视觉特效相同的技术，但不一定追求图像要看起来逼真。

* **CAD/CAM** 代表计算机辅助设计和计算机辅助制造。这些领域使用计算机技术在计算机上设计零件和产品，以及这些虚拟设计来指导制造过程。例如许多机械零件都在 3D 计算机建模软件中进行设计，然后通过计算机控制的铣床自动生产。

* **仿真** 可以被看作是某种精密的视频游戏。例如，飞行模拟器使用复杂的 3D 图形来模拟驾驶飞机的体验。这样的仿真对于安全关键领域的初始培训（如驾驶）以及经验丰富的用户的场景培训非常有用，毕竟这在物理上模拟这些情景的成本高昂而且非常危险。

* **医学成像** 创建显示被扫描患者数据的有意义的图像。例如，计算机断层扫描（CT）数据集由大量的 3D 密度值组成。计算机图形学用于创建阴影图像，帮助医生从这些数据中提取最重要的信息。

* **信息可视化** 创建关于数据的图像，这些数据不一定具有“自然”的视觉显示。例如，十种不同股票价格的时间趋势并没有明显的视觉显示，但可以使用巧妙的图形技术帮助人们看到这些数据中的模式。

# 1.3 图形学 API
使用图形库的关键部分是处理图形 API。应用程序接口（API）是一组标准的函数集，用于执行一组相关的操作，而图形 API 是一组执行基本图形操作的函数，例如在屏幕上绘制图像和 3D 表面。

每个图形程序都需要能够使用两个相关的 API：一个用于可视输出的图形 API，一个用于从用户那里获取输入的用户界面 API。目前，图形和用户界面 API 有两种主要的范式。第一种是集成方法，以 Java 为例，Java 的图形和用户界面工具包是集成的、可移植的包，完全标准化并作为语言的一部分得到支持。第二种由 Direct3D 和 OpenGL 代表，它们是软件库的一部分，并且与 C++ 之类的语言绑定，而用户界面软件则是一个独立的实体，会因系统而异。在后一种方法中，编写可移植代码存在问题，尽管对于简单的程序，可以使用可移植的库的层次来封装系统特定的用户界面代码。

无论你选择的API是什么，基本的图形调用都差不多相同，本书的概念也都适用。

# 1.4 图形管线
每台台式计算机今天都配备了强大的3D图形管线。这是一个专门的软硬件子系统，能够高效地以透视方式绘制3D基元。这些系统通常被优化用于处理具有共享顶点的3D三角形。管线中的基本操作将3D顶点位置映射到2D屏幕位置，并对三角形进行着色，使其看起来既真实又按正确的后前顺序呈现。

以正确的前后顺序绘制三角形曾经是计算机图形学中最重要的研究问题，现在基本都使用 z-buffer 来解决这个问题。z-buffer 使用特殊的内存缓冲以暴力法解决这个问题。

图形管线中使用的几何操作基本可以完全在一个由三个传统几何坐标和第四个齐次坐标组成的4D坐标空间中完成，以便完成透视变换。4D 坐标使用 4×4 矩阵和 4 维向量进行操作。因此，图形管线包含了大量用于高效处理和组合这些矩阵和向量的机制。这个 4D 坐标系统是计算机科学中使用的最微妙和最美丽的构造之一。并且在学习计算机图形学时，它们无疑是最大的智力难题。每一本图形学教材的第一部分都会涉及这些坐标。

图像生成的速度完全得看绘制的三角形数量。在许多应用中，与视觉质量相比，交互性更为重要。因此有必要将用于表示模型的三角形数量最小化。此外，如果模型在远处查看，则需要的三角形数量较少，而在近距离查看模型时需要较多的三角形。这表明使用不同级别的细节（LOD）表示模型会很有用。

# 1.5 数值问题
许多图形程序实质上只是一堆 3D 数值代码。在这类程序中，数值问题至关重要。在“旧时代”，以健壮且可移植的方式处理这类问题非常困难，因为不同的机器对数字有不同的内部表示，更糟糕的是，它们以不同且不兼容的方式处理异常。幸运的是，几乎所有现代计算机都符合 IEEE 浮点标准（IEEE Standards Association，1985），这使得程序员可以对某些数值条件的处理做出许多方便的假设。

尽管 IEEE 浮点具有许多在编写数值算法时非常有价值的特性，但在图形处理中，大多数情况下只有少数几个是必须要了解的。首先，也是最重要的一点，是要理解在 IEEE 中有三个“特殊值”用于表示实数：

1. **无穷(∞)** 比其他任何有效数值都要大的有效数字。
2. **负无穷(-∞)** 比其他任何有效数值都要小的有效数字。
3. **Nan(Not a number)** 无效数字，由未定义的操作后果得出，例如除以 0.

> tips
> IEEE 浮点数有两种 0 的表示方式，其中一个为正数，另一个为负数。-0 和 +0 的区别只有再某些情况下有用，但是得铭记于心以在这些情况下发生时应对。

IEEE 浮点的设计者做出了一些对程序员非常方便的决策，其中许多与上述处理诸如除零之类异常的三个特殊值相关。在这些情况下，异常会被记录，但在许多情况下程序员可以忽略它。具体而言，对于任何正实数 a ，涉及除以无穷大值的以下规则成立：

+a / (+∞) = +0，
-a / (+∞) = -0，
+a / (-∞) = -0，
-a / (-∞) = +0。

同样对于正数a，涉及无穷大值的其他操作的规则如下：

∞ + ∞ = +∞，
∞ - ∞ = NaN，
∞ × ∞ = ∞，
∞ / ∞ = NaN，
∞ / a = ∞，
∞ / 0 = ∞，
0 / 0 = NaN。

涉及无穷大值的布尔布尔表达式的规则如下：

1. 所有有效数字小于+∞，
2. 所有有效数字大于-∞，
3. -∞小于+∞。

涉及 NaN 的表达式规则如下：

1. 任何包含 NaN 的计算式的结果为 NaN，
2. 任何包含 NaN 的布尔表达式结果为 false。

也许 IEEE 浮点最有用的一点是如何处理除零；对于任何正实数a，涉及除零值的以下规则成立：
在可能出现负零（-0）的情况下需要谨慎对待。
+ a / +0 = +∞，
- a / +0 = −∞。
如果程序员充分利用 IEEE 规则，许多数值计算将变得更加简单。例如，考虑表达式：
$ a=\frac{1}{\frac{1}{b} + \frac{1}{c} } $
这样的表达式在电阻器和透镜中经常出现。如果除零导致程序崩溃（在 IEEE 浮点之前的许多系统中就是这样的），那么需要两个 if 语句来检查b或c的小值或零值。相反，在 IEEE 浮点中，如果b或c为零，我们将得到所需的零值。另一种避免特殊检查的常见技术是利用NaN的布尔属性。考虑以下代码段：
```python
a = f(x)
if (a > 0) then
    do something
```
此处，函数 f 可能返回“丑陋”的值，如 ∞ 或 NaN ，但if条件仍然是明确定义的：对于 a = NaN 或a =  -∞ ，它为false，对于 a = +∞ ，它为true。通过谨慎地决定返回哪些值，通常可以让 if 做出正确的选择，无需特殊检查。这使得程序更小、更健壮、更高效。

# 1.6 效率
提高代码效率并没有什么神奇法则。效率是通过谨慎权衡实现的，并且这些权衡在不同的体系结构中是不同的。而在可预见的未来内，一个良好的经验法则是：程序员应该更关注内存访问模式，而不是操作次数。这与二十年前的最佳经验法则相反。这种转变是因为内存的速度跟不上处理器速度。由于这种趋势长期保持，对于优化来说，有限且一致的内存访问的重要性只增不减。

提高代码速度的一个合理方法是参照以下顺序，仅采取必要的步骤：

1. 以尽可能直接的方式编写代码。根据需要在运行时计算中间结果，而不是将它们存储起来。
2. 以优化模式编译代码。
3. 使用任何现有的性能分析工具来查找关键瓶颈。
4. 检查数据结构以寻找改善局部性的方法。如果可能，使数据单元大小与目标体系结构上的缓存/页面大小匹配。
5. 如果性能分析显示数值计算存在瓶颈，请查看编译器生成的汇编代码，以查找未经优化的地方。根据发现的任何问题重写源代码。


这些步骤中最重要的是第一步。大多数 “优化” 会使代码变得更难阅读，而不会提高速度。此外，花费在一开始优化代码的时间通常用于修复错误或添加功能会更好。并且要注意来自旧文档的建议；一些经典的技巧，如使用整数而不是实数，可能不再提高速度，因为现代 CPU 通常可以执行浮点运算和整数运算一样快。在所有情况下，需要使用性能分析来确保对于特定的机器和编译器，是否每一个优化都是有价值的。

# 1.7 设计并编写图形程序
图形编程经常使用某些设计。本节将介绍一些有助于你实现本书中学到的方法的建议。

## 1.7.1 类设计
图形程序的关键是对图形实体设计良好的类或例程，例如向量、矩阵，RGB 色彩和图像等。这些例程应尽可能干净和高效。一个普遍的设计问题是 locations（位置） 和 displacements（距离） 是否应该单独为一类，因为它们有不同的操作；例如，一个 location 乘以二分之一在几何上没有意义，而二分之一的 displacement 则有意义。在这个问题上的争论可以引起图形从业者之间数个小时的激辩。但在此处我们假设不做区分。

> 我非常信奉 KISS（“keep it simple, stupid”）原则，从这个角度看，两类的论点不足以证明增加的复杂性是合理的。 —P.S

> 我喜欢将 points 和 vectors 分开，因为这使代码更具可读性，并且可以让编译器捕捉到一些错误。 —S.M.

需要编写一些基本类，包括：

- **vector2** 一个2D vector 类，存储 x 和 y 分量。它应该在一个长度为2的数组中存储这些分量，以便良好地支持索引操作符。还应包括 vector 相加、vector 相减、点积、叉积、标量乘法和标量除法的操作。
- **vector3** 一个类似于 vector2 的3D vector 类。
- **hvector** 一个具有四个分量的 homogeneous vector（详见第8章）。
- **rgb** 一个存储三个分量的 RGB color 类。还应包括 RGB 相加、RGB 相减、RGB 乘法、标量乘法和标量除法的操作。
- **transform** 一个用于变换的 4 × 4 矩阵类。应包括矩阵乘法和应用于 locations、directions 和 surface normal vectors 的成员函数。正如第7章所示，这些都是不同的。
- **image** 一个包含 RGB 像素的 2D 数组，并具有输出操作。

此外，可以选择是否添加表示区间、正交归一基和坐标框架的类。

> 你还可以考虑为单位长度 vectors 创建一个特殊类，尽管我发现它们带来的麻烦多于它们的价值。 —P.S.

## 1.7.2 Float vs. Double
现代架构表明，减少内存使用和保持内存访问的连贯性是提高效率的关键。也就是说应该使用单精度数据。然而，为了避免数值问题，则应该使用双精度运算。权衡取决于程序，但在类定义中最好有一个默认选择。

> 我建议在几何计算中使用 double，在颜色计算中使用 float。对于占用大量内存的数据，如三角网格，我建议存储 float 数据，但在通过成员函数访问数据时转换为 double。 —P.S.

> 我主张所有计算都使用 float，直到发现某个特定代码部分需要 double 精度的证据为止。 —S.M.

## 1.7.3
如果你询问周围的人，你会发现随着程序员经验的增加，他们使用传统调试器的频率越来越低。原因之一是，对于复杂程序而言，使用此类调试器比使用简单程序更加麻烦。另一个原因是，最困难的错误是概念性错误，即实现了错误的内容，很容易浪费大量时间逐步查看变量值却无法检测到这些情况。我们发现了几种在图形学中特别有用的调试策略。

### 科学方法
在图形程序中，有一种传统调试的替代方法通常非常有用。它的缺点在于，它与计算机程序员在职业生涯初期被教导不要做的事情非常相似，因此你可能会觉得“不守规矩”：我们创建一个图像并观察其中的问题。然后，我们提出一个假设来解释问题的原因，并进行测试。

例如，在光线追踪程序中，我们可能会发现许多看起来有些随机的黑色像素。这是大多数人编写光线追踪器时会遇到的经典“阴影痤疮”（shadow acne）问题。传统的调试在这里不起作用；相反，我们必须意识到阴影射线击中了正在着色的表面。我们可以注意到黑斑的颜色是环境光颜色，因此直射光缺失了。由于直射光可以在阴影中关闭，因此我们可以假设有些不在阴影中的点被错误地标记为在阴影中。为了测试这个假设，我们可以关闭阴影检查并重新编译。这将表明这些是错误的阴影测试，然后我们可以继续我们的排查工作。这种方法有时可以作为良好实践的关键原因是，我们从不去寻找错误的值或者完全明确我们的概念错误。相反，我们只是通过实验逐步缩小了我们的概念错误。通常，只需要几次试验就可以找到问题的根源，而且这种调试方式非常有意思。

### 使用输出图像进行代码调试
在许多情况下，从图形程序中获取调试信息的最简单途径是直接输出图像本身。如果你想了解某个变量在每个像素计算中的值，你可以暂时修改程序，直接将该值复制到输出图像中，并跳过通常会执行的其他计算步骤。例如，如果你怀疑表面法线导致了着色问题，你可以直接将法线向量复制到图像中（x 分量对应红色通道，y 分量对应绿色通道，z 分量对应蓝色通道），从而在图像中用颜色编码展示实际用于计算的向量。如果你怀疑某个特定值可能超出了有效范围，可以让程序在发生这种情况时在图像中写入鲜红色的像素。

其他常见的技巧包括用明显颜色绘制表面的背面（当它们不应该可见时），按对象的 ID 号对图像进行着色，或者根据像素计算所需的工作量进行着色。

### 使用调试器
在某些情况下，特别是当科学方法似乎导致矛盾时，准确观察发生了是最好的方法。问题在于，图形程序通常涉及对相同代码的多次执行（例如，每个像素一次，或每个三角形一次），从头开始在调试器中逐步执行是完全不切实际的。而且，最困难的 bug 通常只会出现在复杂的输入情况下。

一个有用的方法是为 bug “设置陷阱”。首先，确保程序是确定的 -- 在单个线程中运行，并确保所有随机数都是从固定种子计算出来的。然后，找出哪个像素或三角形出现了 bug，并在怀疑有问题的代码之前添加一个语句，仅在怀疑的情况下执行。例如，如果发现像素 (126, 247) 出现了 bug，那么可以添加如下语句：

```pseudo
if x = 126 and y = 247 then
    print “blarg!”
```

如果在 print 语句上设置断点，就可以在计算您感兴趣的像素之前进入调试器。一些调试器还具有“条件断点”功能，可以在不修改代码的情况下实现相同的效果。

在程序崩溃的情况下，传统调试器对于定位崩溃位置非常有用。然后，你应该回溯程序，使用断言和重新编译，找出程序出错的位置。这些断言应该留在程序中，以应对可能出现的未来 bug。并且再次避免了传统的逐步执行过程，因传统方法不会给程序增加有价值的断言。

> 我喜欢格式化调试打印语句，使输出恰好成为 MATLAB 或 Gnuplot 脚本，以生成有用的图表。 —S.M.

## 附注
关于软件工程的讨论受到《Effective C++》系列（Meyers, 1995, 1997）、极限编程（Extreme Programming，Beck & Andres, 2004）以及《编程实践》（The Practice of Programming，Kernighan & Pike, 1999）的影响。关于实验调试的讨论基于与 Steve Parker 的讨论。与计算机图形相关的年度会议包括 ACM SIGGRAPH 和 SIGGRAPH Asia、Graphics Interface、游戏开发者大会（GDC）、Eurographics、Pacific Graphics、High Performance Graphics、Eurographics 渲染研讨会以及 IEEE VisWeek。这些会议可以通过网上搜索它们的名称来轻松找到。